# A.39. Таймер, тикер и планировщик

В пакете есть несколько функций, `time` которые можно использовать для задержки или управления расписанием выполнения процесса в течение определенного промежутка времени.

## A.39.1. функция `time.Sleep()`

Эта функция используется для мгновенного останова программы. `time.Sleep()` является **блокирование** , заявление ниже не будет выполняться до тех пор , после увольнения. Простой пример реализации можно увидеть в следующем коде.

```
package main

import "fmt"
import "time"

func main () {
    fmt.Println("start")
    time.Sleep(time.Second * 4)
    fmt.Println("after 4 seconds")
}

```

В результате `"start"` появляется надпись , затем через 4 секунды `"after 4 seconds"` появляется надпись .

## A.39.2. Использование планировщика `time.Sleep()`

В дополнение к блокированию процессов `time.Sleep()` эта функция может использоваться для создания простого планировщика, например, следующим образом, планировщика для отображения приветственных сообщений каждую 1 секунду.

```
for true {
    fmt.Println("Hello !!")
    time.Sleep(1 * time.Second)
}

```

## A.39.3. функция `time.NewTimer()`

Эта функция немного отличается от `time.Sleep()` . Функция `time.NewTimer()` возвращает объект типа, `*time.Timer` который имеет свойство `C` типа канала.

Как работает эта функция: по истечении заданного времени данные будут передаваться по каналу `C` . Использование этой функции должно сопровождаться оператором для получения данных из канала `C` .

Для более подробной информации, пожалуйста, обратите внимание на следующий код.

```
var timer = time.NewTimer(4 * time.Second)
fmt.Println("start")
<-timer.C
fmt.Println("finish")

```

Оператор `var timer = time.NewTimer(4 * time.Second)` указывает, что данные будут отправлены на канал `timer.C` через 4 секунды. Строка кода `<-timer.C` означает получение данных из канала `timer.C` . Поскольку сам прием канала блокируется, `fmt.Println("finish")` новый оператор будет выполнен через **4 секунды** .

В результате выполнения программы, приведенной выше, `"start"` появляется надпись , затем через 4 секунды `"expired"` появляется надпись .

## A.39.4. функция `time.AfterFunc()`

Функция `time.AfterFunc()` имеет 2 параметра. Первый параметр \- это длительность таймера, а второй параметр \- *обратный вызов* . Обратный вызов будет выполнен, если время отработало длительность таймера.

```
var ch = make(chan bool)

time.AfterFunc(4*time.Second, func() {
    fmt.Println("expired")
    ch <- true
})

fmt.Println("start")
<-ch
fmt.Println("finish")

```

Результаты приведенного выше кода, запись `"start"` появляется спустя 4 секунды, `"expired"` появляется запись .

В обратном вызове происходит процесс передачи данных по каналу, благодаря чему запись `"finish"` появляется сразу после появления записи `"expired"` .

Некоторые вещи, которые следует знать при использовании этой функции:

*   Если передача данных по каналу отсутствует, то выполнение `time.AfterFunc()` выполняется асинхронно (не блокируется).
*   Если происходит передача данных через канал, то функция продолжит работать асинхронно до строки кода, где выполняется прием данных канала. Процесс блокировки происходит в строке кода приема канала.

## A.39.5. функция `time.After()`

Полезность этой функции аналогична `time.Sleep()` . Разница в том, что функция `timer.After()` вернет канал данных, поэтому необходимо использовать знак `<-` в своем приложении.

```
<-time.After(4 * time.Second)
fmt.Println("expired")

```

Текст `"expired"` появится через 4 секунды.

## A.39.6. Планировщик, использующий тикер

В дополнение к функциям для целей таймера Go также предоставляет функцию планировщика (здесь мы называем это тикером).

Как использовать тикер, довольно просто, создайте новый объект тикера, используя `time.NewTicker()` содержимое аргумента с желаемой продолжительностью. Из этого объекта мы можем получить доступ к свойству, `.C` которое является каналом. Каждую длительность, которая была прервана, объект тикера будет отправлять информацию о дате и времени через канал.

```
package main

import (
    "fmt"
    "time"
)

func main() {
    done := make(chan bool)
    ticker := time.NewTicker(time.Second)

    go func() {
        time.Sleep(10 * time.Second) // wait for 10 seconds
        done <- true
    }()

    for {
        select {
        case <-done:
            ticker.Stop()
            return
        case t := <-ticker.C:
            fmt.Println("Hello !!", t)
        }
    }
}

```

В приведенном выше примере это видно, помимо тикера также подготовлена ​​переменная канала `done` . Мы используем эту переменную для контроля, когда тикер должен быть остановлен.

Как работает программа выше: техника `for` \- `select` канал используется для проверки приема данных с канала `done` и `ticker.C` . По умолчанию канал `ticker.C` будет получать данные каждые N продолжительности, которая в приведенном выше коде составляет 1 секунду (см. Аргумент инициализации объекта тикера).

Данные, отправленные по каналу, `ticker.C` являются датой и временем, когда произошло событие. В приведенном выше коде каждый раз, когда мы отправляем данные через канал, мы отображаем их.

Перед кодом цикла `for` мы видим, что отправляется новая процедура, содержимое которой отправляет данные в канал `done` через 10 секунд. Данные будут позже получены блоком кода `for` \- `select` и когда это произойдет, `.Stop()` вызывается метод, принадлежащий объекту тикера, чтобы деактивировать планировщик на этом тикере.

Таким образом, в течение 10 секунд сообщение приветствия будет появляться каждую секунду.

## A.39.7. Сочетание таймера и рутины

Ниже приведен пример реализации таймера и режима работы. Программа ниже представляет собой простую программу вопросов и ответов. Возникает вопрос, и пользователь должен ввести ответ не более, чем за 5 секунд. Если прошло 5 секунд и ответа нет, появится сообщение об истечении *времени ожидания* .

Хорошо, давайте продолжим, давайте сделаем программу, во\-первых, импортируем необходимые пакеты.

```
package main

import "fmt"
import "os"
import "time"

```

Создайте функцию `timer()` , эта функция будет выполнена как goroutine. В функции `timer()` есть блок кода, если время достигло `timeout` , то данные передаются по каналу `ch` .

```
func timer(timeout int, ch chan<- bool) {
    time.AfterFunc(time.Duration(timeout)*time.Second, func() {
        ch <- true
    })
}

```

Подготовьте функцию тоже `watcher()` . Эта функция также будет выполнена как goroutine. Задача довольно проста: получение данных из канала `ch` (если есть прием данных, это означает, что истекло время ожидания), а затем выводит сообщение о том, что время истекло.

```
func watcher(timeout int, ch <-chan bool) {
    <-ch
    fmt.Println("\ntime out! no answer more than", timeout, "seconds")
    os.Exit(0)
}

```

Наконец, сделайте реализацию в функции `main()` .

```
func main() {
    var timeout = 5
    var ch = make(chan bool)

    go timer(timeout, ch)
    go watcher(timeout, ch)

    var input string
    fmt.Print("what is 725/25 ? ")
    fmt.Scan(&input)

    if input == "29" {
        fmt.Println("the answer is right!")
    } else {
        fmt.Println("the answer is wrong!")
    }
}

```

Когда пользователь ничего не вводит в течение 5 секунд, появится сообщение об истечении времени ожидания, затем программа остановится.

![Применение таймера в рутине](https://dasarpemrogramangolang.novalagung.com/images/A.39_1_timer.png)

# П.36. Ошибка, Паника, Ден Восстановление

Ошибка \- очень важная тема в программировании на Go. В этом разделе мы узнаем об использовании ошибок и о том, как создавать собственные ошибки. Кроме того, мы также узнаем об использовании **паники,** чтобы вызвать ошибки паники, и **восстановиться,** чтобы их преодолеть.

## A.36.1. Использование ошибок

`error` это тип. Ошибка имеет 1 свойство в виде метода `Error()` , этот метод возвращает подробности сообщения об ошибке в строке. Ошибка включает в себя тип, содержимое которого может быть `nil` .

В Go есть много функций, которые возвращают более одного возвращаемого значения. Обычно одним изменением является тип `error` . Например, как в функции `strconv.Atoi()` . Функция используется для преобразования строковых данных в числовые. Эта функция возвращает 2 возвращаемых значения. Первое возвращаемое значение является результатом преобразования, а второе возвращаемое значение является `error` . Когда преобразование проходит гладко, второе возвращаемое значение будет стоить `nil` . Между тем, когда преобразование завершается неудачно, причина может быть немедленно известна из возвращенной ошибки.

Ниже приведен пример простой программы для обнаружения ввода от пользователей, будь то числовой или нет. Отсюда мы узнаем об использовании ошибок.

```
package main

import (
    "fmt"
    "strconv"
)

func main() {
    var input string
    fmt.Print("Type some number: ")
    fmt.Scanln(&input)

    var number int
    var err error
    number, err = strconv.Atoi(input)

    if err == nil {
        fmt.Println(number, "is number")
    } else {
        fmt.Println(input, "is not number")
        fmt.Println(err.Error())
    }
}

```

Запустите программу, появится надпись `"Type some number: "` . Введите бесплатный номер, если у вас есть, затем введите.

Оператор `fmt.Scanln(&input)` используется для захвата ввода, введенного пользователем, до того, как он нажмет ввод, а затем сохранит его как строку в переменной `input` .

Затем переменная преобразуется в числовой тип с помощью `strconv.Atoi()` . Функция возвращает 2 данных, собранных `number` и `err` .

Первые данные ( `number` ) содержат результаты конвертации. И вторые данные `err` , содержат информацию об ошибке (если ошибка произошла в процессе преобразования).

После этого проверяется, когда нет ошибок, `number` отображается. И если есть ошибка, она `input` отображается вместе с сообщением об ошибке.

Сообщения об ошибках могут быть получены из метода `Error()` типа `error` .

![Применение ошибки](https://dasarpemrogramangolang.novalagung.com/images/A.36_1_error.png)

## A.36.2. Сделать пользовательскую ошибку

Помимо использования ошибок, возникающих в результате возврата доступной внутренней функции, мы также можем создать объект ошибки самостоятельно, используя функцию `errors.New()` ( `errors` сначала необходимо импортировать пакет ).

В следующем примере показано, как создать пользовательскую ошибку. Сначала подготовьте функцию по имени `validate()` , которая будет использоваться для проверки ввода, является ли ввод пустым или нет. Когда пусто, новая ошибка будет сделана.

```
package main

import (
    "errors"
    "fmt"
    "strings"
)

func validate(input string) (bool, error) {
    if strings.TrimSpace(input) == "" {
        return false, errors.New("cannot be empty")
    }
    return true, nil
}

```

Затем в основной функции выполните простой процесс захвата ввода пользователя. Используйте функцию `validate()` для проверки ввода.

```
func main() {
    var name string
    fmt.Print("Type your name: ")
    fmt.Scanln(&name)

    if valid, err := validate(name); valid {
        fmt.Println("halo", name)
    } else {
        fmt.Println(err.Error())
    }
}

```

Функция `validate()` возвращает 2 данных. Первые данные \- это значение, `bool` которое указывает, действителен ли ввод или нет. Вторые данные \- это сообщение об ошибке (если ввод неверен).

Функция `strings.TrimSpace()` используется для удаления символа пробела до и после строки. Это необходимо, потому что пользователь может просто ввести пробел, а затем ввести.

Когда ввод недействителен, новая ошибка сделана с использованием функции `errors.New()` . Кроме того, объекты ошибок также могут быть созданы с помощью функций `fmt.Errorf()` .

![Пользовательская ошибка](https://dasarpemrogramangolang.novalagung.com/images/A.36_2_custom_error.png)

## A.36.3. использование `panic`

Паника используется для отображения ошибки *трассировки стека* при остановке потока программы (поскольку `main()` это также программа, то применяется то же поведение). После возникновения паники процесс остановится, все, что не выполнено, кроме процесса, который был ранее заблокирован (появится перед ошибкой паники).

Panic отображает сообщение об ошибке на консоли, так же, как `fmt.Println()` . Отображаемая информация об ошибке является ошибкой трассировки стека, поэтому она очень подробна и взволнована.

Возвращаясь к коду, в программе, которую мы создали ранее, измените `fmt.Println()` то , что находится внутри блока условий `else` основной функции `panic()` , а затем добавьте `fmt.Println()` .

```
func main() {
    var name string
    fmt.Print("Type your name: ")
    fmt.Scanln(&name)

    if valid, err := validate(name); valid {
        fmt.Println("halo", name)
    } else {
        fmt.Println(err.Error())
        fmt.Println("end")
    }
}

```

Запустите программу и сразу нажмите Enter, затем появится паническая ошибка и следующая строка кода не будет запущена.

![Отображение ошибок с использованием паники](https://dasarpemrogramangolang.novalagung.com/images/A.36_3_panic.png)

## A.36.4. использование `recover`

Восстановление полезно для обработки панических ошибок. При возникновении ошибки паники восстановите приемную программу, находящуюся в состоянии паники (сообщение о панике не появится).

Хорошо, давайте немного изменим приведенные выше функции, чтобы попрактиковаться в использовании recovery. Добавьте функцию `catch()` , в этой функции есть утверждение, `recover()` что он вернет сообщение об ошибке паники, которое должно появиться.

Чтобы использовать функцию восстановления, функцию / замыкание / IIFE, где она `recover()` должна выполняться, следует выполнить с помощью отсрочивания.

```
func catch() {
    if r := recover(); r != nil {
        fmt.Println("Error occured", r)
    } else {
        fmt.Println("Application running perfectly")
    }
}

func main() {
    defer catch()

    var name string
    fmt.Print("Type your name: ")
    fmt.Scanln(&name)

    if valid, err := validate(name); valid {
        fmt.Println("halo", name)
    } else {
        panic(err.Error())
        fmt.Println("end")
    }
}

```

Выход:

![Справиться с паникой с помощью восстановления](https://dasarpemrogramangolang.novalagung.com/images/A.36_4_recover.png)

## A.36.5. Утилизация `recover` в IIFE

Примеры применения восстановления на IIFE:

```
func main() {
    defer func() {
        if r := recover(); r != nil {
            fmt.Println("Panic occured", r)
        } else {
            fmt.Println("Application running perfectly")
        }
    }()

    panic("some error happen")
}

```

В реальных разработках иногда требуется восстановление не во внешнем функциональном блоке, а в более конкретном функциональном блоке.

Пожалуйста, рассмотрите следующий пример кода восстановления цикла. Как правило, если возникает ошибка паники, процесс в рамках функционального блока будет остановлен, в результате чего цикл также будет остановлен принудительно. В следующем примере мы пытаемся применить способы обработки панических ошибок без остановки самого цикла.

```
func main() {
    data := []string{"superman", "aquaman", "wonder woman"}

    for _, each := range data {

        func() {

            // recover untuk IIFE dalam perulangan
            defer func() {
                if r := recover(); r != nil {
                    fmt.Println("Panic occured on looping", each, "| message:", r)
                } else {
                    fmt.Println("Application running perfectly")
                }
            }()

            panic("some error happen")
        }()

    }
}

```

В приведенном выше коде в цикле видно, что существует IIFE для восстановления паники, а также есть код для принудительного запуска панической ошибки. Когда возникает ошибка паники, в идеале цикл останавливается, но в приведенном выше примере этого не происходит, потому что операция цикла инкапсулирована в IIFE, и, как мы знаем, природа ошибки паники заключается в принудительном останове процесса в области действия функционального блока.

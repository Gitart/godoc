# С.22. HTTPS / TLS веб\-сервер

В этом разделе мы узнаем, как включить средства SSL / TLS на веб\-сервере.

## C.22.1. определение

#### • SSL

**SSL, Secure Sockets Layer** , является стандартом для обеспечения безопасности связи через Интернет. Данные или информация, которые передаются из одной системы в другую, будут защищены путем скремблирования информации с использованием алгоритма шифрования.

#### • SSL\-сертификаты

**Сертификат SSL** \- это файл, содержащий информацию о сайте, которая понадобится для шифрования данных. Сертификат SSL содержит **открытый ключ** . Открытый ключ используется для шифрования передаваемых данных.

Сертификаты имеют цифровую подпись Центров **сертификации (CA)** . Цифровая подпись или цифровая подпись \- это уникальный код, созданный с помощью технологии криптографии **(инфраструктуры открытых ключей)** .

Центр сертификации сам по себе является юридическим лицом или учреждением, которое выдает и проверяет цифровые сертификаты.

Когда пользователь Интернета посещает веб\-сайт, на котором веб\-сайт реализует SSL, отправленная информация будет надежно зашифрована (с использованием открытого ключа) и может быть расшифрована только с помощью **закрытого ключа** .

Закрытый ключ или секретный ключ \- это отдельный файл, который необходим в процессе расшифровки данных, зашифрованных с использованием открытого ключа.

Ниже приводится пояснение в виде изображений, взятых с [сайта coinjolt.com](https://coinjolt.com/what-is-a-public-and-private-key/) .

![анатомия](https://dasarpemrogramangolang.novalagung.com/images/C.22_1_public_and_private_key.png)

Как файлы сертификатов, так и файлы закрытых ключей должны храниться на сервере в очень безопасном месте.

#### • TLS

**TLS, Transport Layer Security** , является более обновленной версией SSL.

#### • HTTPS

**HTTPS, Hyper Text Transfer Protocol Secure** , является расширением HTTP, которое полезно для защиты связи через Интернет. Данные или информация, которые передаются, шифруются с использованием **TLS** .

## C.22.2. Создать закрытый ключ и открытый ключ для использования `openssl`

Для реализации TLS на веб\-сервере приложений Golang сначала необходимо подготовить закрытый ключ и открытый ключ.

Используйте `openssl` для генерации закрытого ключа.

```
$ openssl genrsa -out server.key 2048
$ openssl ecparam -genkey -name secp384r1 -out server.key

```

Две команды выше производят `server.key` закрытый ключ. После этого создайте *самозаверяющий* сертификат (содержащий открытый ключ) созданного закрытого ключа.

```
$ openssl req -new -x509 -sha256 -key server.key -out server.crt -days 3650

```

Команда для генерации сертификата выше вызовет форму. Требуется заполнение такой информации, как адрес, адрес электронной почты, хост, убедитесь, что содержимое корректно, особенно в разделах **«Общее имя»** и « **Адрес электронной почты»** .

*   В разделе общего имени заполните **localhost** .
*   Для содержимого электронной почты с действительным адресом электронной почты.

Это выглядит более или менее как на следующем скриншоте.

![Генерация закрытого ключа и сертификата](https://dasarpemrogramangolang.novalagung.com/images/C.22_1.1_public_and_private_key.png)

> Помимо `.crt` и `.key` , есть и другие расширения, как `.pem` . `.pem` Этот формат является типом кодировки, который очень часто используется в похожих криптографических файлах `.key` и `.crt` . Файлы `.crt` и `.key` могут быть преобразованы в `.pem` , и наоборот.

## C.22.3. Структура проекта

Создайте проект папки, скопируйте 2 файла, которые были сгенерированы в него. Затем подготовьте файл `main.go` .

![Структура папок](https://dasarpemrogramangolang.novalagung.com/images/C.22_2_structure.png)

## C.22.4. Веб\-серверы

В `main.go` , подготовьте функцию `StartNonTLSServer()` , содержащую mux с одной маршрутизацией, для перенаправления запросов из протокола `http` в `https` . Позже все запросы, которые указывают , перенаправляются на . Запустите Mux в порту . `[http://localhost](http://localhost)` `[https://localhost](https://localhost)` `:80`

```go
package main

import (
    "log"
    "net/http"
)

func StartNonTLSServer() {
    mux := new(http.ServeMux)
    mux.Handle("/", http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        log.Println("Redirecting to https://localhost/")
        http.Redirect(w, r, "https://localhost/", http.StatusTemporaryRedirect)
    }))

    http.ListenAndServe(":80", mux)
}

```

Затем в функции `main()` создайте еще один новый мультиплексор с содержимым одной маршрутизации, отображающий текст «Hello World!». Start mux использует `http.ListenAndServeTLS()` порт `:443` , не забывая вставить путь к секретному ключу и файлу открытого ключа в качестве аргументов функции.

```go
func main() {
    go StartNonTLSServer()

    mux := new(http.ServeMux)
    mux.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
        w.Write([]byte("Hello World!"))
    })

    log.Println("Server started at :443")
    err := http.ListenAndServeTLS(":443", "server.crt", "server.key", mux)
    if err != nil {
        panic(err)
    }
}

```

Чтобы не забыть, функция `StartNonTLSServer()` также вызывается `main()` . Таким образом, в одной программе работают 2 веб\-сервера.

ОК, запустите приложение.

> Если возникает ошибка `panic: listen tcp :443: bind: permission denied` , попробуйте запустить приложение с помощью **sudo** , например: `sudo go run main.go`

## C.22.5. тестирование

Тестовое приложение с использованием `curl` . Чтобы запросить протокол, `https` попробуйте добавить флаг, `--insecure` чтобы отключить сертификаты проверки.

![пример завитка](https://dasarpemrogramangolang.novalagung.com/images/C.22_3_curl_example.png)

Попробуйте также протестировать с помощью браузера, если вы используете Chrome, появится предупреждение. `NET::ERR_CERT_AUTHORITY_INVALID` Нажмите **Дополнительно → Перейти к локальному хосту (небезопасно)** .

![пример браузера](https://dasarpemrogramangolang.novalagung.com/images/C.22_4_browser_example.png)

Предупреждение `NET::ERR_CERT_AUTHORITY_INVALID` появляется при доступе к веб\-сайту с использованием протокола, `https` в котором этот веб\-сайт применяет **самозаверяющий сертификат** , но не использует сертификат, проверенный ЦС.

# B.21. HTTP\-куки

Файлы cookie \- это данные в виде текста, которые хранятся на компьютере (с помощью веб\-браузера), когда посетители просматривают сайт. Cookies могут быть сделаны из внешнего интерфейса (javascript) или внутреннего интерфейса (в этом контексте Go).

Файлы cookie являются важным аспектом при разработке веб\-приложений. Очень часто нам нужны данные, которые могут быть сохранены и доступны для целей нашего веб\-приложения, таких как проверка предпочтений посетителей, проверка статуса входа пользователя.

В этой главе мы узнаем, как создавать и получать доступ к файлам cookie на ходу.

## B.21.1. практика

Создайте папку проекта, подготовьте один файл `main.go` . Создайте функцию `main()` , зарегистрируйте два маршрута.

```
package main

import (
    "fmt"
    "github.com/novalagung/gubrak"
    "net/http"
    "time"
)

type M map[string]interface{}

var cookieName = "CookieData"

func main() {
    http.HandleFunc("/", ActionIndex)
    http.HandleFunc("/delete", ActionDelete)

    fmt.Println("server started at localhost:9000")
    http.ListenAndServe(":9000", nil)
}

```

Переменные, `cookieName` содержащие строки, позже используемые в качестве имен файлов cookie.

*   Маршруту `/` поручено создать новый файл cookie (если он еще не существует или файл cookie уже существует, но срок его действия истек).
*   Маршрут `/delete` имеет задачу удаления куки, а затем перенаправить его на `/` создание нового куки

Хорошо, теперь сделайте функцию обработчика `ActionIndex()` . В этой функции случайные строковые данные хранятся в файлах cookie.

```
func ActionIndex(w http.ResponseWriter, r *http.Request) {
    cookieName := "CookieData"

    c := &http.Cookie{}

    if storedCookie, _ := r.Cookie(cookieName); storedCookie != nil {
        c = storedCookie
    }

    if c.Value == "" {
        c = &http.Cookie{}
        c.Name = cookieName
        c.Value = gubrak.RandomString(32)
        c.Expires = time.Now().Add(5 * time.Minute)
        http.SetCookie(w, c)
    }

    w.Write([]byte(c.Value))
}

```

К файлам cookie можно получить доступ через `.Cookie()` метод объекта `*http.Request` . Этот метод возвращает 2 информации:

*   Объект cookie
*   Ошибка, если применимо

В приведенном выше коде, когда `storedCookie` значение не является `nil` (то есть файл cookie с именем `cookieName` был создан), тогда объект cookie сохраняется в `c` .

Создание куки довольно просто, просто распечатайте новый объект из структуры `http.Cookie` .

Если он `c.Value` пуст, мы предполагаем, что файл cookie никогда не создавался (или срок его действия не истек), тогда мы создаем новый файл cookie с данными, которые представляют собой случайную строку.

> Чтобы упростить генерацию случайных строк, мы используем библиотеку под названием [gubrak](https://github.com/novalagung/gubrak) . Функция `gubrak.RandomString(32)` выдаст 32\-символьную строку.

Срок действия файлов cookie истек. Продолжительность активного cookie определяется через свойство `Expires` . В приведенном выше коде мы устанавливаем срок действия 5 минут.

Используйте, `http.SetCookie()` чтобы сохранить только что созданный файл cookie.

Хорошо, тогда сделайте обработчик `ActionDelete()` , как упомянуто выше. Этот обработчик используется для удаления файлов cookie по имени `cookieName` , а затем перенаправления на него `/` для создания новых файлов cookie.

```
func ActionDelete(w http.ResponseWriter, r *http.Request) {
    c := &http.Cookie{}
    c.Name = cookieName
    c.Expires = time.Unix(0, 0)
    c.MaxAge = -1
    http.SetCookie(w, c)

    http.Redirect(w, r, "/", http.StatusTemporaryRedirect)
}

```

Как удалить куки, чтобы сбросить куки с тем же именем, с содержанием собственности `Expires = time.Unix(0, 0)` и `MaxAge = -1` . Цель состоит в том, чтобы срок действия файла cookie истек.

## B.21.2. тестирование

Запустите приложение, затем получите доступ `/` . На экране появится случайная строка, и если мы проверим заголовок ответа, также появится информация о куки.

![печенье](https://dasarpemrogramangolang.novalagung.com/images/B.21_1_cookie.png)

Попробуйте обновить страницу несколько раз, информация о заголовке файла cookie и отображаемые данные совпадают. Потому что, когда cookie был установлен, эта конечная точка будет использовать сохраненные данные cookie.

Затем откройте URL `/delete` , страница будет перенаправлена ​​обратно `/` , и будет создана новая случайная строка вместе с новым файлом cookie. В этой конечной точке файлы cookie удаляются, и поскольку следующим шагом является перенаправление `/` , процесс проверки и создания файлов cookie будет перезапущен. Посетители получат новые данные cookie с тем же именем.

## B.21.3. Свойства объекта `http.Cookie`

Объект cookie имеет несколько свойств, некоторые из которых:

| собственности | Тип данных | описание |
| --- | --- | --- |
| значение | `string` | Данные хранятся в куки |
| путь | `string` | Cookie области действия |
| Домен | `string` | Область действия файлов cookie |
| Истекает | `time.Time` | Продолжительность куки, написанная по типу `time.Time` |
| MaxAge | `int` | Продолжительность куки, записанная в секундах (числовая) |
| Безопасный | `bool` | Область применения файлов cookie в контексте протокола, используемого при доступе к сети. Этот прокси полезен, только если включены веб\-серверы SSL / TLS.
*   Если `false` , то куки\-файл, который сохраняется при доступе к сети по протоколу `http://` , все еще может быть доступен через `https://` и применяется к противоположному.
*   Если `true` во время доступа по протоколу `https://` данные cookie будут зашифрованы. Принимая во внимание, что доступ через протокол `http://` cookie сохраняется как обычно (без шифрования). Если на одном веб\-сервере доступны два протокола, `https://` и `https://` вышеупомянутые правила все еще применяются к каждому протоколу, при этом сохраняемые данные записи `https://` могут быть доступны только через этот протокол.

 |
| HttpOnly | `bool` |

*   Если `false` , то куки могут быть сделаны через серверную часть (Go) или через интерфейс (javascript)
*   Если `true` , то куки могут быть созданы только из серверной части

 |

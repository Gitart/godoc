# П.40. Преобразование между типами данных

В предыдущих главах мы применяли некоторый способ преобразования данных, такие как преобразование `string` ↔ `int` использование `strconv` и `time.Time` ↔ `string` . В этой главе мы узнаем больше.

## A.40.1. Использование конверсии `strconv`

Пакет `strconv` содержит много функций, которые действительно помогают нам сделать преобразование. Ниже приведены некоторые функции в пакете.

### A.40.1.1. функция `strconv.Atoi()`

Эта функция используется для преобразования данных из типа `string` в `int` . `strconv.Atoi()` производит 2 части возвращаемого значения, результат преобразования и `error` (если преобразование прошло успешно, то оно `error` содержит `nil` ).

```
package main

import "fmt"
import "strconv"

func main() {
    var str = "124"
    var num, err = strconv.Atoi(str)

    if err == nil {
        fmt.Println(num) // 124
    }
}

```

### A.40.1.2. функция `strconv.Itoa()`

Является противоположностью `strconv.Atoi` , полезной для преобразования `int` в `string` .

```
var num = 124
var str = strconv.Itoa(num)

fmt.Println(str) // "124"

```

### A.40.1.3. функция `strconv.ParseInt()`

Используется для преобразования `string` чисел на определенной основе в недесятичные числовые типы с шириной данных, которую можно определить.

В следующем примере строка `"124"` преобразуется в числовой тип с использованием базовых условий `10` и ширины данных, следующих за типом `int64` (см. Третий параметр).

```
var str = "124"
var num, err = strconv.ParseInt(str, 10, 64)

if err == nil {
    fmt.Println(num) // 124
}

```

В другом примере строка `"1010"` преобразуется в базу 2 (двоичную) с типом данных результата `int8` .

```
var str = "1010"
var num, err = strconv.ParseInt(str, 2, 8)

if err == nil {
    fmt.Println(num) // 10
}

```

### A.40.1.4. функция `strconv.FormatInt()`

Полезно для преобразования числовых данных `int64` в `string` числовую основу можно определить самостоятельно.

```
var num = int64(24)
var str = strconv.FormatInt(num, 8)

fmt.Println(str) // 30

```

### A.40.1.5. функция `strconv.ParseFloat()`

Используется для преобразования `string` в десятичное число с шириной данных.

```
var str = "24.12"
var num, err = strconv.ParseFloat(str, 32)

if err == nil {
    fmt.Println(num) // 24.1200008392334
}

```

В приведенном выше примере строка `"24.12"` преобразуется в число с плавающей точкой с шириной типа данных `float32` . Результаты преобразования `strconv.ParseFloat` соответствуют [стандарту IEEE для арифметики с плавающей точкой](https://en.wikipedia.org/wiki/IEEE_floating_point) .

### A.40.1.6. функция `strconv.FormatFloat()`

Полезно для преобразования данных типа `float64` в `string` экспоненциальный формат, можно определить ширину десятичной цифры и ширину типа данных.

```
var num = float64(24.12)
var str = strconv.FormatFloat(num, 'f', 6, 64)

fmt.Println(str) // 24.120000

```

В приведенном выше коде данные `24.12` типа `float64` преобразуются в строку с форматом экспоненты `f` или без экспоненты, шириной в 6 десятичных разрядов и шириной типа данных `float64` .

Существует несколько форматов экспоненты, которые можно использовать. Подробности можно увидеть в следующей таблице.

| Формат экспоненты | объяснение |
| --- | --- |
| `b` | \-ddddp ± ddd, a, бинарный показатель (основание 2) |
| `e` | \-d.dddde ± dd, a, десятичный показатель (основание 10) |
| `E` | \-d.ddddE ± dd, a, десятичный показатель (основание 10) |
| `f` | \-ddd.dddd, без показателей степени |
| `g` | Будет использовать формат экспоненты `e` для больших экспонентов и `f` для других |
| `G` | Будет использовать формат экспоненты `E` для больших экспонентов и `f` для других |

### A.40.1.7. функция `strconv.ParseBool()`

Используется для преобразования `string` в `bool` .

```
var str = "true"
var bul, err = strconv.ParseBool(str)

if err == nil {
    fmt.Println(bul) // true
}

```

### A.40.1.8. функция `strconv.FormatBool()`

Используется для преобразования `bool` в `string` .

```
var bul = true
var str = strconv.FormatBool(bul)

fmt.Println(str) // 124

```

## A.40.2. Преобразование данных с использованием методов приведения

Ключевые слова типа данных могут использоваться для приведения или преобразования между типами данных. Как использовать это, чтобы написать целевое приведение типа данных как функцию, а затем вставить данные для преобразования в качестве параметра функции.

```
var a float64 = float64(24)
fmt.Println(a) // 24

var b int32 = int32(24.00)
fmt.Println(b) // 24

```

## A.40.3. Кастинг `string` ↔ `byte`

Фактическая строка \- это ломтик / массив `byte` . В Go обычный символ (не unicode) представлен байтовым элементом слайса. Каждый элемент слайса содержит данные `int` с десятичной основой, которая является кодом ASCII символов в строке.

Чтобы получить байты фрагмента из строки данных, приведите ее к типу `[]byte` .

```
var text1 = "halo"
var b = []byte(text1)

fmt.Printf("%d %d %d %d \n", b[0], b[1], b[2], b[3])
// 104 97 108 111

```

В приведенном выше примере строка в переменной `text1` преобразуется в `[]byte` . Каждый элемент байта слайса затем отображается один за другим.

Следующий пример, противоположный приведенному выше, `[]byte` будет выполняться поиск данных типа `string` .

```
var byte1 = []byte{104, 97, 108, 111}
var s = string(byte1)

fmt.Printf("%s \n", s)
// halo

```

В приведенном выше примере некоторый байт\-код записывается в виде слайсов, хранящихся в виде переменных `byte1` . Затем значение переменной приводится к `string` , а затем отображается.

Кроме того, каждая символьная строка также может быть преобразована в форму `int` , результат такой же, т.е. байтовые данные в числовой форме в десятичном формате, при условии, что используемая литеральная строка является кавычкой one ( `'` ).

Обратное также применимо, числовые данные, если приводятся к строке, определяются как код ASCII из генерируемых символов.

```
var c int64 = int64('h')
fmt.Println(c) // 104

var d string = string(104)
fmt.Println(d) // h

```

## A.40.4. Тип Утверждения Pada Интерфейс Kosong ( `interface{}` )

**Утверждения типа** \- это методы для извлечения конкретных типов данных из данных, которые заключены в `interface{}` . Таким образом, можно сделать вывод, что техника утверждений типа может быть выполнена только на данных типа `interface{}` . Для более подробной информации, пожалуйста, проверьте следующий пример.

`data` Подготовленные переменные имеют тип `map[string]interface{}` , карта содержит несколько элементов с различными типами значений данных, а тип данных для ключа одинаков `string` .

```
var data = map[string]interface{}{
    "nama":    "john wick",
    "grade":   2,
    "height":  156.5,
    "isMale":  true,
    "hobbies": []string{"eating", "sleeping"},
}

fmt.Println(data["nama"].(string))
fmt.Println(data["grade"].(int))
fmt.Println(data["height"].(float64))
fmt.Println(data["isMale"].(bool))
fmt.Println(data["hobbies"].([]string))

```

`data["nama"].(string)` Смысл заявления заключается в том, что значение `data["nama"]` типа `interface{}` принимает конкретное значение в виде строки `string` .

В приведенном выше коде паническая ошибка не возникнет, поскольку все операции подтверждения типа выполняются с использованием типов данных, которые соответствуют типу данных исходного значения. Как `data["nama"]` это, `string` безусловно, можно утверждать, чтобы напечатать `string` .

Попробуйте сделать утверждение для типа, который не соответствует исходному типу значения, например `data["nama"].(int)` , это определенно вызовет паническую ошибку.

Теперь из приведенного выше объяснения следует, что мы должны заранее знать, какой исходный тип данных взят из данных, хранящихся в интерфейсе. Если, например, вы не знаете, то вы можете использовать методы ниже, чтобы проверить успех или неудачу процесса диссертации.

Исходный тип данных для переменной `interface{}` может быть определен путем приведения к типу `type` , но это может быть выполнено только в `switch` .

```
for _, val := range data {
    switch val.(type) {
    case string:
        fmt.Println(val.(string))
    case int:
        fmt.Println(val.(int))
    case float64:
        fmt.Println(val.(float64))
    case bool:
        fmt.Println(val.(bool))
    case []string:
        fmt.Println(val.([]string))
    default:
        fmt.Println(val.(int))
    }
}

```

Комбинация `switch` \- `case` может использоваться для обнаружения конкретных типов типов данных `interface{}` , примеров их применения, как в приведенном выше коде.

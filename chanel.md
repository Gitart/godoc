# П.30. канал

**Канал** используется для соединения одной программы с другой. Используемый механизм \- передача данных через канал. В своем сообщении канал выполняет функции отправителя в программе, а также в качестве получателя в другой программе. Отправка и получение данных по каналу является **блокирующим** или **синхронным** .

![Аналоговый канал](https://dasarpemrogramangolang.novalagung.com/images/A.30_1_analogy.png)

В этой главе мы узнаем об использовании канала.

## A.30.1. Применение канала

Канал \- это переменная, созданная с использованием комбинации ключевых слов `make` и `chan` . Переменная канала имеет одну задачу \- быть отправителем или получателем данных.

Следующая программа является примером реализации канала. Было выполнено 3 процедуры, в каждой из которых был процесс отправки данных по каналу. Данные будут получены 3 раза в основной программе `main` .

```
package main

import "fmt"
import "runtime"

func main() {
    runtime.GOMAXPROCS(2)

    var messages = make(chan string)

    var sayHelloTo = func(who string) {
        var data = fmt.Sprintf("hello %s", who)
        messages <- data
    }

    go sayHelloTo("john wick")
    go sayHelloTo("ethan hunt")
    go sayHelloTo("jason bourne")

    var message1 = <-messages
    fmt.Println(message1)

    var message2 = <-messages
    fmt.Println(message2)

    var message3 = <-messages
    fmt.Println(message3)
}

```

В приведенном выше коде `messages` объявлена переменная типа channel `string` . Как создать канал, написав ключевые слова `make` с содержанием ключевых слов, `chan` за которым следует нужный тип канала данных.

```
var messages = make(chan string)

```

Кроме того, готовится также замыкание, `sayHelloTo` задачей которого является создание строки сообщения, которая затем отправляется по каналу. Строка сообщения отправляется через канал `messages` . `<-` Если знак написан слева от имени переменной, это означает процесс отправки данных из переменной вправо через канал слева (в этом контексте переменная `data` отправляется через канал `messages` ).

```
var sayHelloTo = func(who string) {
    var data = fmt.Sprintf("hello %s", who)
    messages <- data
}

```

Функция `sayHelloTo` выполняется три раза как другая процедура. Заставить эти три процесса работать **асинхронно** или не ожидать друг друга.

> Еще раз имейте в виду, что выполнение goroutine является *асинхронным* , в то время как передача данных между каналами является *синхронной* .

```
go sayHelloTo("john wick")
go sayHelloTo("ethan hunt")
go sayHelloTo("jason bourne")

```

Из трех функций, процедура, выполняющая самые ранние этапы, сначала отправит данные, затем данные будут приняты как переменные `message1` . Знак, `<-` если он записан справа от канала, указывает на процесс получения данных из канала справа, которые будут сохранены в переменной слева.

```
var message1 = <-messages
fmt.Println(message1)

```

Канал приема блокируется. Это означает, что операторы `var message1 = <-messages` до тех пор, пока не будут выполнены, не будут переданы через канал.

Все данные , передаваемые из трех различных goroutine данные будут получены в последовательности, `message1` , `message2` , `message3` ; чтобы затем отображаться.

![Реализация канала](https://dasarpemrogramangolang.novalagung.com/images/A.30_2_channel.png)

Из приведенного выше снимка экрана видно, что возвращаемый текст `sayHelloTo` не всегда является последовательным, даже если данные приема являются последовательными. Это связано с тем, что передача данных осуществляется от 3\-х различных программ, которые мы не знаем, какой процесс завершается первым. Запрограммированное ранее выполнение Goroutine не обязательно завершается досрочно, но ясно, что завершенный ранее процесс будет получен раньше.

Поскольку отправка и получение данных по каналам является **блокировкой** , нет необходимости использовать свойства блокировки аналогичных `fmt.Scanln()` или других функций в ожидании завершения основной процедуры `main` до завершения трех указанных выше процедур.

## A.30.2. Канал как тип данных параметра

Переменные канала могут быть переданы другим функциям в качестве параметров. Просто добавьте ключевые слова `chan` в объявление параметра, чтобы можно было выполнить операцию с переменным проходным каналом.

Подготовьте функцию `printMessage` с параметрами канала. Затем извлеките данные, отправленные через этот канал, для отображения.

```
func printMessage(what chan string) {
    fmt.Println(<-what)
}

```

После этого измените реализацию в функции `main` .

```
func main() {
    runtime.GOMAXPROCS(2)

    var messages = make(chan string)

    for _, each := range []string{"wick", "hunt", "bourne"} {
        go func(who string) {
            var data = fmt.Sprintf("hello %s", who)
            messages <- data
        }(each)
    }

    for i := 0; i < 3; i++ {
        printMessage(messages)
    }
}

```

Вывод программы выше такой же, как и в предыдущей программе.

Параметры `what` функции `printMessage` типа канала `string` , можно увидеть из кода `chan string` в методе объявления. Операции передачи данных могут выполняться над этими переменными, а также будут влиять на переменные `messages` в функции `main` .

Передача данных типа канала **передается по ссылке** , указатель является указателем данных, а не значением данных.

![Канал параметров](https://dasarpemrogramangolang.novalagung.com/images/A.30_3_channel_param.png)

---

Ниже приведено дополнительное объяснение приведенного выше кода.

### A.30.2.1. Итерация данных среза / массива непосредственно во время инициализации

Вновь инициализированные данные срезов можно итерировать напрямую, их легко записать сразу после ключевого слова `range` .

```
for _, each := range []string{"wick", "hunt", "bourne"} {
    // ...
}

```

### A.30.2.2. Goroutine Казнь в IIFE

Выполнение Goroutine не обязательно должно быть определенной функцией или замыканием. IIFE также может быть запущен как новая программа. Вы делаете это путем непосредственного добавления ключевых слов `go` во время выполнения декларации IIFE.

```
var messages = make(chan string)

go func(who string) {
    var data = fmt.Sprintf("hello %s", who)
    messages <- data
}("wick")

var message = <-messages
fmt.Println(message)
```

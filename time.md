# П.38. Время, время разбора и время форматирования

В этой главе мы узнаем об использовании данных типа дата\-время, предоставленных методах, а также о **формате** и **разборе** данных `string` для ввода `time.Time` и наоборот.

Go предоставляет пакеты, `time` которые содержат множество компонентов, которые можно использовать для целей использования даты и времени. Одним из них является `time.Time` тип данных даты и времени на Go.

> Время здесь означает комбинацию **даты** и **времени** , а не только времени.

## A.38.1. использование `time.Time`

Типы `time.Time` являются представлениями для объектов даты и времени. Существует 2 способа создания данных этого типа.

1.  Создание информации о текущем времени объектом `time.Time` , используя `time.Now()` .
2.  Или создайте новый объект типа `time.Time` с самоопределенной информацией, используйте `time.Date()` .

Ниже приведен пример его использования.

```
package main

import "fmt"
import "time"

func main() {
    var time1 = time.Now()
    fmt.Printf("time1 %v\n", time1)
    // time1 2015-09-01 17:59:31.73600891 +0700 WIB

    var time2 = time.Date(2011, 12, 24, 10, 20, 0, 0, time.UTC)
    fmt.Printf("time2 %v\n", time2)
    // time2 2011-12-24 10:20:00 +0000 UTC
}

```

Функция `time.Now()` возвращает объекты `time.Time` с информацией, являющейся точной датой\-временем выполнения инструкции. Можно увидеть, когда печатается информация о дате и времени в соответствии с датой выполнения программы.

![Использование времени](https://dasarpemrogramangolang.novalagung.com/images/A.38_1_time_instance.png)

Функция `time.Date()` используется для создания `time.Time` новых объектов, для которых мы указываем информацию о дате и времени. Эта функция имеет 8 *обязательных* параметров со схемой, которую можно увидеть в следующем коде:

```
time.Date(tahun, bulan, tanggal, jam, menit, detik, nanodetik, timezone)

```

Функция печати объекта `time.Now()` , информация о его часовом поясе относительно нашего местоположения. Поскольку совпадение автора находится в Восточной Яве, оно будет обнаружено введенным в **GMT + 7** или **WIB** . В отличие от переменной `time2` , местоположение которой мы явно указали, это **UTC** .

Помимо использования `time.UTC` для определения местоположения, есть также `time.Local` значение, относящееся к нашему местному времени и дате.

## A.38.2. Собственный метод `time.Time`

Тип данных `time.Time` является структурой, имеет несколько методов, которые можно использовать.

```
var now = time.Now()
fmt.Println("year:", now.Year(), "month:", now.Month())
// year: 2015 month: 8

```

Приведенный выше код является примером использования нескольких методов, принадлежащих к типам объектов `time.Time` . Метод `Year()` возвращает информацию о году и `Month()` возвращает информацию о номере месяца.

В дополнение к двум вышеописанным методам можно использовать еще много других. В следующей таблице перечислены методы, связанные с *датой* , *временем* и *расположением* типа `time.Time` .

| метод | Тип возврата | объяснение |
| --- | --- | --- |
| `now.Year()` | `int` | год |
| `now.YearDay()` | `int` | День до? начиная с начала года |
| `now.Month()` | `int` | Луна |
| `now.Weekday()` | `string` | Название дня Можно использовать, `now.Weekday().String()` чтобы принять форму строки |
| `now.ISOWeek()` | (`int`, `int`) | Годы и недели? начиная с начала года |
| `now.Day()` | `int` | дата |
| `now.Hour()` | `int` | час |
| `now.Minute()` | `int` | минут |
| `now.Second()` | `int` | второй |
| `now.Nanosecond()` | `int` | Нано секунд |
| `now.Local()` | `time.Time` | Дата\-время в местном часовом поясе |
| `now.Location()` | `*time.Location` | Получить информацию о местоположении, будь то *локальный* или *UTC* . Можно использовать, `now.Location().String()` чтобы принять форму строки |
| `now.Zone()` | ( `string` , `int` ) | Возвращает информацию о *смещении часового пояса* в виде строки и числа. Например `WIB, 25200` |
| `now.IsZero()` | `bool` | Обнаружение ли значение объекта `now` является `01 Januari tahun 1, 00:00:00 UTC` . Если так, то оно того стоит `true` |
| `now.UTC()` | `time.Time` | Дата\-время Далам часовой пояс `UTC` |
| `now.Unix()` | `int64` | Дата\-время Далам Формат *Unix Время* |
| `now.UnixNano()` | `int64` | Дата\-время в формате *unix time* . Нано вторая информация также включена |
| `now.String()` | `string` | Дата\-время в строке |

## A.38.3. Разбор от `string` до `time.Time`

Данные `string` могут быть преобразованы в `time.Time` использование `time.Parse` . Эта функция требует 2 параметра:

*   Первый формат макета из данных, которые будут разобраны.
*   Вторая строка данных, которые будут разобраны.

Примеры его применения можно увидеть в следующем коде.

```
var layoutFormat, value string
var date-time.Time

layoutFormat = "2006-01-02 15:04:05"
value = "2015-09-02 08:04:00"
date, _ = time.Parse(layoutFormat, value)
fmt.Println(value, "\t->", date.String())
// 2015-09-02 08:04:00 +0000 UTC

layoutFormat = "02/01/2006 MST"
value = "02/09/2015 WIB"
date, _ = time.Parse(layoutFormat, value)
fmt.Println(value, "\t\t->", date.String())
// 2015-09-02 00:00:00 +0700 WIB

```

![Пример использования ** time.Parse **](https://dasarpemrogramangolang.novalagung.com/images/A.38_2_time_parse.png)

Формат формата даты и времени в Go отличается от других языков. Как правило, используемый формат макета, как `"DD/MM/YYYY"` в Go нет.

Go имеет стандартный формат макета, который является совершенно уникальным, например, как в коде выше `"2006-01-02 15:04:05"` . Иди используй это `2006` для разбора года, верно `YYYY` ; `01` для разбора луны; `02` для дневного разбора; и так далее. Подробности можно увидеть в следующей таблице.

| Формат макета | объяснение | Пример данных |
| --- | --- | --- |
| `2006` | Год 4 цифры | `2015` |
| `006` | Год 3 цифры | `015` |
| `06` | Год 2 цифры | `15` |
| `01` | Месяц 2 цифры | `05` |
| `1` | Луна на 1 цифру меньше 10 месяцев, кроме 2 цифр | `5`, `12` |
| `January` | Название месяца на английском | `September` , `August` |
| `Jan` | Название месяца на английском языке, 3 буквы | `Sep` , `Aug` |
| `02` | 2\-я цифра | `02` |
| `2` | 1\-я цифра меньше 10 месяцев, в дополнение к 2 цифрам | `8` , `31` |
| `Monday` | Название дня на английском | `Saturday` , `Friday` |
| `Mon` | Название дня на английском, 3 буквы | `Sat` , `Fri` |
| `15` | **24 часовой** формат | `18` |
| `03` | Часы с **12\-часовым** двухзначным форматом | `05` , `11` |
| `3` | **12\-часовые** часы с 1\-значным форматом, если до 11 часов, кроме 2\-х цифр | `5` , `11` |
| `PM` | AM / PM, обычно используемый в **12\-часовом** формате часов | `PM`, `AM` |
| `04` | 2 цифры минуты | `08` |
| `4` | 1 цифра минуты, если меньше 10 минут, кроме 2 цифр | `8` , `24` |
| `05` | 2\-значные секунды | `06` |
| `5` | 1 цифра секунд, если меньше 10 секунд, кроме 2 цифр | `6` , `36` |
| `999999` | Нано секунд | `124006` |
| `MST` | Часовой пояс | `UTC`, `WIB`, `EST` |
| `Z0700` | Смещение часового пояса | `Z` , `+0700` , `-0200` |

## A.38.4. Предопределенный формат макета с целью анализа времени

Go также предоставляет несколько общих предопределенных форматов макета, которые можно использовать. Таким образом, нет необходимости писать комбинацию компонентов компоновки.

Один предопределенный макет, который можно использовать `time.RFC822` , эквивалентен формату макета `02 Jan 06 15:04 MST` . Ниже приведен пример его применения.

```
var date, _ = time.Parse(time.RFC822, "02 Sep 15 08:00 WIB")
fmt.Println(date.String())
// 2015-09-02 08:00:00 +0700 WIB

```

Доступны несколько других форматов форматов, см. Следующую таблицу.

| Предопределенный формат макета | Формат макета |
| --- | --- |
| `time.ANSIC` | Мой Ян \_2 15:04:05 2006 |
| `time.UnixDate` | Мой Ян \_2 15:04:05 MST 2006 |
| `time.RubyDate` | Мой янв 02 15:04:05 \-0700 2006 |
| `time.RFC822` | 02 января 06 15:04 MST |
| `time.RFC822Z` | 02 января 06 15:04 \-0700 |
| `time.RFC850` | Понедельник, 02.01.2006 15:04:05 MST |
| `time.RFC1123` | Понедельник, 02 Янв 2006 15:04:05 MST |
| `time.RFC1123Z` | Понедельник, 02 января 2006 г. 15:04:05 \-0700 |
| `time.RFC3339` | 2006\-01\-02T15: 04: 05Z07: 00 |
| `time.RFC3339Nano` | 2006\-01\-02T15: 04: 05.999999999Z07: 00 |
| `time.Kitchen` | 3:04 вечера |
| `time.Stamp` | Янв \_2 15:04:05 |
| `time.StampMilli` | Ян\_2 15: 04: 05.000 |
| `time.StampMicro` | Янв2: 15: 04: 05.000000 |
| `time.StampNano` | Янв2: 15: 04: 05.000000000 |

## A.38.5. Формат от `time.Time` до `string`

После того, как ранее мы узнали о том, как преобразовать данные с типом `string` в `time.Time` . На этот раз мы узнаем обратное, преобразование `time.Time` в `string` .

Метод `Format()` типа `time.Time` используется для формирования выходных данных в `string` соответствии с желаемой разметкой формата. Примеры можно увидеть в следующем коде.

```
var date, _ = time.Parse(time.RFC822, "02 Sep 15 08:00 WIB")

var dateS1 = date.Format("Monday 02, January 2006 15:04 MST")
fmt.Println("dateS1", dateS1)
// Wednesday 02, September 2015 08:00 WIB

var dateS2 = date.Format(time.RFC3339)
fmt.Println("dateS2", dateS2)
// 2015-09-02T08:00:00+07:00

```

Переменная `date` выше содержит результаты анализа данных в формате `time.RFC822` . Затем данные форматируются в виде строки 2 раза с другим форматом.

![Пример использования метода `Format ()`](https://dasarpemrogramangolang.novalagung.com/images/A.38_3_time_format.png)

## A.38.6. Обработка ошибок при разборе `time.Time`

При разборе `string` к `time.Time` , возможно ошибка может возникать из \- за структуры данных , которые будут разобраны , не совпадает расположение используемого формата. Могут ли ошибки синтаксического анализа быть обнаружены через возвращаемое значение двух функций `time.Parse()` . Ниже приведен пример его применения.

```
var date, err = time.Parse("06 Jan 15", "02 Sep 15 08:00 WIB")

if err != nil {
    fmt.Println("error", err.Error())
    return
}

fmt.Println(date)

```

Приведенный выше код выдает ошибку, потому что формат не соответствует схеме данных для анализа. Формат макета, который следует использовать, это `06 Jan 15 03:04 MST` .

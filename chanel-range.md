# П.33. Канал \- Диапазон Дан Закрыть

Процесс извлечения данных из многих каналов может быть легче сделать с помощью комбинации ключевых слов `for` \- `range` .

`for` \- `range` применительно к каналу он функционирует для обработки приема данных. Каждый раз, когда происходит передача данных по каналу, он запускает цикл `for` \- `range` . Цикл будет продолжаться непрерывно, так как данные отправляются на используемый канал. И зацикливание остановится только в том случае, если используемый канал **закрыт** или деактивирован. Функция `close` используется для деактивации канала.

Закрытые каналы не могут больше использоваться для получения данных или для отправки данных, поэтому цикл `for` \- `range` также останавливается.

## A.33.1. Применение `for` \- `range` \- `close` на канале

Ниже приведен пример использования программы `for` \- `range` получить данные из канала.

Хорошо, сначала подготовьте функцию `sendMessage()` , работа которой заключается в отправке данных по каналу. В этой функции это повторяется 20 раз, каждый раз, когда данные отправляются на канал. Канал закрывается после отправки всех данных.

```
func sendMessage(ch chan<- string) {
    for i := 0; i < 20; i++ {
        ch <- fmt.Sprintf("data %d", i)
    }
    close(ch)
}

```

Также подготовьте функции `printMessage()` для обработки данных. В этой функции каналы зацикливаются с использованием `for` \- `range` . На каждом цикле отображаются данные, полученные из канала.

```
func printMessage(ch <-chan string) {
    for message := range ch {
        fmt.Println(message)
    }
}

```

Создайте новый канал в функции `main()` , запустите его `sendMessage()` в качестве программы (следовательно, 20 данных, содержащихся в функции, отправляются через новую программу). Не забывайте также выполнять функции `printMessage()` .

```
func main() {
    runtime.GOMAXPROCS(2)

    var messages = make(chan string)
    go sendMessage(messages)
    printMessage(messages)
}

```

После того, как 20 данных были успешно отправлены и получены, канал `ch` деактивируется ( `close(ch)` ). Создание цикла каналов данных `printMessage()` также прекратится.

![Приложение для закрытия диапазона на канале](https://dasarpemrogramangolang.novalagung.com/images/A.33_1_for_range_close.png)

---

Вот дополнительное объяснение канала.

## A.33.1.1. Направление канала

В функции параметров канала, предоставляемой Go, есть что\-то уникальное. Уровень доступа к каналу может быть определен как в качестве получателя, отправителя или получателя, так и отправителя. Эта концепция называется **направлением канала** .

Как обеспечить уровни доступа, это добавить знак `<-` до или после ключевого слова `chan` . Более подробную информацию можно увидеть в следующем списке.

| синтаксис | объяснение |
| --- | --- |
| `ch chan string` | Параметры `ch` могут быть использованы для **отправки** и **получения** данных |
| `ch chan<- string` | Параметр `ch` может использоваться только для **отправки** данных |
| `ch <-chan string` | Параметр `ch` может использоваться только для **получения** данных |

В приведенном выше коде видно, что по умолчанию канал будет иметь возможность отправлять и получать данные. Чтобы изменить канал так, чтобы он мог только отправлять или получать, используя символы `<-` .

Например, функция `sendMessage(ch chan<- string)` , параметры которой `ch` объявлены с уровнем доступа только для отправки данных. Канал может быть использован только для передачи, например: `ch <- fmt.Sprintf("data %d", i)` .

И наоборот, в функции `printMessage(ch <-chan string)` канал `ch` может использоваться только для приема данных.

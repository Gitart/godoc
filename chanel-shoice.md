# П.32. Канал \- Выбрать

Предоставление каналов позволяет инженерам легко управлять распорядком. Но имейте в виду, что даже несмотря на то, что канал управления процедурами упрощается, основная функция канала заключается не в управлении, а в обмене данными между программами.

> Далее в [главе A.56. Вайтгруппе](https://dasarpemrogramangolang.novalagung.com/56-waitgroup.html) будет всесторонне обсуждено, как оптимально управлять goroutine.

Бывают случаи, когда нам нужен не один канал для обмена данными между программами. В зависимости от типа случая очень возможно, что требуется более одного канала. Ну, вот где использование `select` . Выбор облегчает управление передачей данных по одному или нескольким каналам.

Способ использования `switch` управления каналом такой же, как и `switch` при выборе условий.

## A.32.1. Реализация ключевых слов `select`

Следующая программа \- простой пример применения выбора в канале. Были подготовлены две программы: одна для среднего поиска и одна для самого высокого балла. Результаты операций с каждой программой передаются в функцию `main()` через канал (есть два канала). В самой функции `main()` данные получены с использованием ключевых слов `select` .

Хорошо, давай просто потренируемся. Сначала подготовьте 2 функции, описанные выше. Первая функция используется для нахождения среднего значения, а вторая \- для определения наибольшего значения среза.

```
package main

import "fmt"
import "runtime"

func getAverage(numbers []int, ch chan float64) {
    var sum = 0
    for _, e := range numbers {
        sum += e
    }
    ch <- float64(sum) / float64(len(numbers))
}

func getMax(numbers []int, ch chan int) {
    var max = numbers[0]
    for _, e := range numbers {
        if max < e {
            max = e
        }
    }
    ch <- max
}

```

Обе функции выполняются как рутина. В конце каждого функционального блока результаты вычислений отправляются через подготовленный канал, то есть `ch1` для хранения средних данных, `ch2` для данных с наивысшим значением.

Хорошо, далее для реализации на функции `main()` .

```
func main() {
    runtime.GOMAXPROCS(2)

    var numbers = []int{3, 4, 3, 5, 6, 3, 2, 2, 6, 3, 4, 6, 3}
    fmt.Println("numbers :", numbers)

    var ch1 = make(chan float64)
    go getAverage(numbers, ch1)

    var ch2 = make(chan int)
    go getMax(numbers, ch2)

    for i := 0; i < 2; i++ {
        select {
        case avg := <-ch1:
            fmt.Printf("Avg \t: %.2f \n", avg)
        case max := <-ch2:
            fmt.Printf("Max \t: %d \n", max)
        }
    }
}

```

В приведенном выше коде, канала передачи данных `ch1` и `ch2` контролируемого использования `select` . Есть два `case` условия для получения данных из двух каналов.

*   Условия `case avg := <-ch1` будут выполнены, когда будет получен прием данных из канала `ch1` , который затем будет учтен переменной `avg` .
*   Условия `case max := <-ch2` будут выполнены, когда будет получен прием данных из канала `ch2` , который затем будет учтен переменной `max` .

Поскольку имеется 2 канала, его необходимо подготовить 2 раза перед использованием ключевых слов `select` .

![Пример применения выбора канала](https://dasarpemrogramangolang.novalagung.com/images/A.32_1_channel_select.png)

Достаточно просто, верно?
